using CryptoBot.Application.LavinMQ.Contract;
using CryptoBot.Application.LavinMQ.Contract.Configs;
using CryptoBot.Application.LavinMQ.Contract.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;

namespace CryptoBot.Application.LavinMQ.Client;

public class LavinMQConsumer<T> : LavinMQClient
    where T : class
{
    private readonly LavinMQConsumerConfig _consumerConfig;
    private readonly ILavinMQReceiveConsumer<T> _receiveConsumer;
    private readonly IServiceScopeFactory _serviceScopeFactory;
    private AsyncEventingBasicConsumer _basicConsumer;
    private SortedDictionary<ulong, LavinMQMessageForConsume<T>> _processes;
    private Task _taskProcess;

    public LavinMQConsumer(LavinMQHostConfig hostConfig, LavinMQConsumerConfig consumerConfig, ILavinMQReceiveConsumer<T> receiveConsumer, IServiceScopeFactory serviceScopeFactory) : base(hostConfig)
    {
        _consumerConfig = consumerConfig;
        _receiveConsumer = receiveConsumer;
        _serviceScopeFactory = serviceScopeFactory;
    }

    public async Task Consume()
    {
        await Connect();

        if (_connection is null)
        {
            throw new InvalidOperationException($"Connection with LavinMQ {_config.HostName} is not open");
        }

        var queueService = new LavinMQQueueService(_consumerConfig.Queue, _channel);

        try
        {
            queueService.Create();
        }
        catch (Exception ex)
        {
            if (ex.Message.Contains("not empty")) await Connect();
            else throw;
        }

        _basicConsumer = new AsyncEventingBasicConsumer(_channel);
        _channel.BasicQos(prefetchSize: 0,
                          prefetchCount: _consumerConfig.PrefetchCount,
                          global: false);
        _channel.BasicConsume(queue: _consumerConfig.Queue.Name,
                              autoAck: _consumerConfig.AutoAck,
                              consumer: _basicConsumer);
        _basicConsumer.Received += ProcessMessage;
    }

    public async Task ProcessMessage(object ch, BasicDeliverEventArgs ea)
    {
        LavinMQMessageForConsume<T> message = ea;
        if (message.Entity != null)
        {
            lock (_processes)
                _processes.Add(ea.DeliveryTag, message);

            if (_taskProcess == null || _taskProcess.IsCompleted)
                _taskProcess = InvokeConsume();
        }
        else
        {
            _channel.BasicNack(deliveryTag: ea.DeliveryTag,
                               multiple: false,
                               requeue: false);
        }
    }

    public async Task InvokeConsume()
    {
        if (_receiveConsumer == null)
            throw new InvalidOperationException("Class for receive message is null");

        while (_processes.Any())
        {
            try
            {
                List<LavinMQMessageForConsume<T>> processes = new(_processes.Select(p => p.Value).ToList());

                IServiceScope scope;
                ILavinMQReceiveConsumer<T> consumer;

                if (!_consumerConfig.AutoGeneratedInstanceOfService)
                {
                    consumer = _receiveConsumer;
                }
                else
                {
                    scope = _serviceScopeFactory.CreateScope();
                    consumer = scope.ServiceProvider.GetRequiredService<ILavinMQReceiveConsumer<T>>();
                }

                var response = await consumer.Receive(processes);
                if (!_consumerConfig.AutoAck)
                {
                    foreach (var message in response.SuccessMessages)
                    {
                        _processes.Remove(message.Key);
                        _channel.BasicAck(deliveryTag: message.Key,
                                          multiple: false);
                    }

                    foreach (var message in response.ErrorMessages)
                    {
                        _processes.Remove(message.Key);
                        _channel.BasicNack(deliveryTag: message.Key,
                                           multiple: false,
                                           requeue: false);
                    }
                }

                ulong[]? keyForRemove = null;
                lock (_processes)
                {
                    var listKeysForRemove = _processes
                        .Where(p => p.Key <= response.SuccessMessages.FirstOrDefault().Key)
                        .Select(p => p.Key)
                        .ToList();
                    var auxiliarKeysForRemove = _processes
                        .Where(p => p.Key <= response.ErrorMessages.FirstOrDefault().Key)
                        .Select(p => p.Key)
                        .ToList();

                    listKeysForRemove.AddRange(auxiliarKeysForRemove);
                    keyForRemove = listKeysForRemove.Where(k => k != 0).ToArray();
                }

                if (keyForRemove != null)
                    foreach (var key in keyForRemove)
                        _processes.Remove(key);
            }
            catch (Exception)
            {
                _channel?.Close();
                _connection?.Close();
            }
        }
    }

    public bool HasConsumer() => _basicConsumer.IsRunning && !_errorConnection;
}