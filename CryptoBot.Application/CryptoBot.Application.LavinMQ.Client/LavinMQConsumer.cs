using CryptoBot.Application.LavinMQ.Contract;
using CryptoBot.Application.LavinMQ.Contract.Configs;
using CryptoBot.Application.LavinMQ.Contract.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;

namespace CryptoBot.Application.LavinMQ.Client;

public class LavinMQConsumer<T> : LavinMQClient, ILavinMQConsumer<T>
    where T : class
{
    private readonly ILavinMQConsumerConfig _consumerConfig;
    private readonly ILavinMQReceiveConsumer<T> _receiveConsumer;
    private readonly IServiceScopeFactory _serviceScopeFactory;
    private AsyncEventingBasicConsumer _basicConsumer;
    private SortedDictionary<ulong, MessageForConsume<T>> _processes = new();
    private Task _taskProcess;

    public LavinMQConsumer(
        LavinMQHostConfig hostConfig,
        ILavinMQConsumerConfig consumerConfig,
        ILavinMQReceiveConsumer<T> receiveConsumer,
        IServiceScopeFactory serviceScopeFactory
    ) : base(hostConfig)
    {
        _consumerConfig = consumerConfig;
        _receiveConsumer = receiveConsumer;
        _serviceScopeFactory = serviceScopeFactory;
    }

    public async Task Consume()
    {
        await Connect();

        if (_connection is null)
        {
            throw new InvalidOperationException($"Connection with LavinMQ {_config.HostName} is not open");
        }

        _basicConsumer = new AsyncEventingBasicConsumer(_channel);
        _channel?.BasicQos(prefetchSize: 0,
                          prefetchCount: _consumerConfig.PrefetchCount,
                          global: false);
        _channel.BasicConsume(queue: _consumerConfig.QueueName,
                              autoAck: _consumerConfig.AutoAck,
                              consumer: _basicConsumer);
        _basicConsumer.Received += ProcessMessage;
    }

    public async Task ProcessMessage(object ch, BasicDeliverEventArgs ea)
    {
        MessageForConsume<T> message = ea;
        if (message.Entity != null)
        {
            lock (_processes)
                _processes.Add(ea.DeliveryTag, message);

            if (_taskProcess == null || _taskProcess.IsCompleted)
                _taskProcess = InvokeConsume();
        }
        else
        {
            _channel?.BasicNack(deliveryTag: ea.DeliveryTag,
                               multiple: false,
                               requeue: false);
        }
    }

    public async Task InvokeConsume()
    {
        if (_receiveConsumer == null)
            throw new InvalidOperationException("Class for receive message is null");

        while (_processes.Any())
        {
            try
            {
                List<MessageForConsume<T>> processes = new(_processes.Select(p => p.Value).ToList());

                IServiceScope scope;
                ILavinMQReceiveConsumer<T> consumer;

                if (!_consumerConfig.AutoGeneratedInstanceOfService)
                {
                    consumer = _receiveConsumer;
                }
                else
                {
                    scope = _serviceScopeFactory.CreateScope();
                    consumer = scope.ServiceProvider.GetRequiredService<ILavinMQReceiveConsumer<T>>();
                }

                var response = await consumer.Receive(processes);
                if (!_consumerConfig.AutoAck)
                {
                    foreach (var message in response.SuccessMessages)
                    {
                        _processes.Remove(message.Key);
                        _channel?.BasicAck(deliveryTag: message.Key,
                                           multiple: false);
                    }

                    foreach (var message in response.ErrorMessages)
                    {
                        _processes.Remove(message.Key);
                        _channel?.BasicNack(deliveryTag: message.Key,
                                            multiple: false,
                                            requeue: false);
                    }

                    ulong[]? keyForRemove = null;
                    lock (_processes)
                    {
                        var listKeysForRemove = _processes
                            .Where(p => p.Key <= response.SuccessMessages.FirstOrDefault().Key)
                            .Select(p => p.Key)
                            .ToList();
                        var auxiliarKeysForRemove = _processes
                            .Where(p => p.Key <= response.ErrorMessages.FirstOrDefault().Key)
                            .Select(p => p.Key)
                            .ToList();

                        listKeysForRemove.AddRange(auxiliarKeysForRemove);
                        keyForRemove = listKeysForRemove.Where(k => k != 0).ToArray();
                    }

                    if (keyForRemove != null)
                        foreach (var key in keyForRemove)
                            _processes.Remove(key);
                }
            }
            catch (Exception)
            {
                _channel?.Close();
                _connection?.Close();
            }
        }
    }

    public bool HasConsumer() => _basicConsumer.IsRunning && !_errorConnection;
}